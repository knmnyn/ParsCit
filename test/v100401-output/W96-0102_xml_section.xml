<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="100401">
<algorithm name="SectLabel" version="100410">
<variant no="0" confidence="0.001330">
<title confidence="0.916721">
MBT: A Memory-Based Part of Speech Tagger-Generator
</title>
<author confidence="0.9586">
Walter Daelemans, Jakub Zavrel
</author>
<affiliation confidence="0.9770445">
Computational Linguistics and AT
Tilburg University
</affiliation>
<address confidence="0.977452">
P.O. Box 90153, NL-5000 LE Tilburg
</address>
<email confidence="0.782587">
fwalter.daelemans,zavrelleaub.n1
</email>
<author confidence="0.990797">
Peter Berck, Steven Gillis
</author>
<affiliation confidence="0.9953225">
Center for Dutch Language and Speech
University of Antwerp
</affiliation>
<address confidence="0.875178">
Universiteitsplein 1, B-2610 Wilrijk
</address>
<email confidence="0.749688">
Ipeter.berck,steven.gillislftia.ua.ac.be
</email>
<sectionHeader confidence="0.955744" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999679055555556">
We introduce a memory-based approach to part of speech tagging. Memory-based
learning is a form of supervised learning based on similarity-based reasoning. The part
of speech tag of a word in a particular context is extrapolated from the most similar
cases held in memory. Supervised learning approaches are useful when a tagged corpus
is available as an example of the desired output of the tagger. Based on such a corpus,
the tagger-generator automatically builds a tagger which is able to tag new text the
same way, diminishing development time for the construction of a tagger considerably.
Memory-based tagging shares this advantage with other statistical or machine learning
approaches. Additional advantages specific to a memory-based approach include (i) the
relatively small tagged corpus size sufficient for training, (ii) incremental learning, (iii)
explanation capabilities, (iv) flexible integration of information in case representations,
(v) its non-parametric nature, (vi) reasonably good results on unknown words without
morphological analysis, and (vii) fast learning and tagging. In this paper we show that
a large-scale application of the memory-based approach is feasible: we obtain a tagging
accuracy that is on a par with that of known statistical approaches, and with attractive
space and time complexity properties when using IGTree, a tree-based formalism for
indexing and searching huge case bases. The use of IGTree has as additional advantage
that optimal context size for disambiguation is dynamically computed.
</bodyText>
<sectionHeader confidence="0.999526" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9979005">
Part of Speech (POS) tagging is a process in which syntactic categories are assigned to
words. It can be seen as a mapping from sentences to strings of tags.
Automatic tagging is useful for a number of applications: as a preprocessing stage
to parsing, in information retrieval, in text to speech systems, in corpus linguistics, etc.
The two factors determining the syntactic category of a word are its lexical probability
(e.g. without context, man is more probably a noun than a verb), and its contextual
probability (e.g. after a pronoun, man is more probably a verb than a noun, as in they
man the boats). Several approaches have been proposed to construct automatic taggers.
Most work on statistical methods has used n-gram models or Hidden Markov Model-based
taggers (e.g. Church, 1988; DeRose, 1988; Cutting et al. 1992; Merialdo, 1994, etc.). In
</bodyText>
<page confidence="0.9996">
14
</page>
<bodyText confidence="0.999731157894737">
these approaches, a tag sequence is chosen for a sentence that maximizes the product of
lexical and contextual probabilities as estimated from a tagged corpus.
In rule-based approaches, words are assigned a tag based on a set of rules and a
lexicon. These rules can either be hand-crafted (Garside et al., 1987; Klein &amp; Simmons,
1963; Green 8.6 Rubin, 1971), or learned, as in Hindle (1989) or the transformation-based
error-driven approach of Brill (1992).
In a memory-based approach, a set of cases is kept in memory. Each case consists of a
word (or a lexical representation for the word) with preceding and following context, and
the corresponding category for that word in that context. A new sentence is tagged by
selecting for each word in the sentence and its context the most similar case(s) in memory,
and extrapolating the category of the word from these &apos;nearest neighbors&apos;. A memory-
based approach has features of both learning rule-based taggers (each case can be regarded
as a very specific rule, the similarity based reasoning as a form of conflict resolution and
rule selection mechanism) and of stochastic taggers: it is fundamentally a form of k-nearest
neighbors (k-nn) modeling, a well-known non-parametric statistical pattern recognition
technique. The approach in its basic form is computationally expensive, however; each
new word in context that has to be tagged, has to be compared to each pattern kept
in memory. In this paper we show that a heuristic case base compression formalism
(Daelemans et al., 1996), makes the memory-based approach computationally attractive.
</bodyText>
<sectionHeader confidence="0.999341" genericHeader="method">
2 Memory-Based Learning
</sectionHeader>
<bodyText confidence="0.999904333333334">
Memory-based Learning is a form of supervised, inductive learning from examples. Ex-
amples are represented as a vector of feature values with an associated category label.
During training, a set of examples (the training set) is presented in an incremental fash-
ion to the classifier, and added to memory. During testing, a set of previously unseen
feature-value patterns (the test set) is presented to the system. For each test pattern, its
distance to all examples in memory is computed, and the category of the least distant
instance(s) is used as the predicted category for the test pattern. The approach is based
on the assumption that reasoning is based on direct reuse of stored experiences rather
than on the application of knowledge (such as rules or decision trees) abstracted from
experience.
In AI, the concept has appeared in several disciplines (from computer vision to robotics),
using terminology such as similarity-based, example-based, memory-based, exemplar-
based, case-based, analogical, lazy, nearest-neighbour, and instance-based (Stanfill and
Waltz, 1986; Kolodner, 1993; Aha et al. 1991; Salzberg, 1990). Ideas about this type of
analogical reasoning can be found also in non-mainstream linguistics and pyscholinguistics
(Skousen, 1989; Derwing Skousen, 1989; Chandler, 1992; Scha, 1992). In computational
linguistics (apart from incidental computational work of the linguists referred to earlier),
the general approach has only recently gained some popularity: e.g., Cardie (1994, syn-
tactic and semantic disambiguation); Daelemans (1995, an overview of work in the early
nineties on memory-based computational phonology and morphology); Jones (1996, an
overview of example-based machine translation research); Federici and Pirrelli (1996).
</bodyText>
<subsectionHeader confidence="0.987249">
2.1 Similarity Metric
</subsectionHeader>
<bodyText confidence="0.968805">
Performance of a memory-based system (accuracy on the test set) crucially depends on
the distance metric (or similarity metric) used. The most straightforward distance metric
would be the one in equation (1), where X and Y are the patterns to be compared, and
6(x, yi) is the distance between the values of the i-th feature in a pattern with n features.
</bodyText>
<page confidence="0.934206">
15
</page>
<equation confidence="0.673533">
A(X, Y) E .6(xi,y•) (1)
</equation>
<bodyText confidence="0.975796133333333">
Distance between two values is measured using equation (2), an overlap metric, for
symbolic features (we will have no numeric features in the tagging application).
S(xt, yz) = 0 if xi = yi, else 1 (2)
We will refer to this approach as IB1 (Aha et al., 1991). We extended the algorithm
described there in the following way: in case a pattern is associated with more than one
category in the training set (i.e. the pattern is ambiguous), the distribution of patterns
over the different categories is kept, and the most frequently occurring category is selected
when the ambiguous pattern is used to extrapolate from.
In this distance metric, all features describing an example are interpreted as being
equally important in solving the classification problem, but this is not necessarily the
case. In tagging, the focus word to be assigned a category is obviously more relevant than
any of the words in its context. We therefore weigh each feature with its information gain;
a number expressing the average amount of reduction of training set information entropy
when knowing the value of the feature (Daelemans &amp; van de Bosch, 1992, Quinlan, 1993;
Hunt et al. 1966) (Equation 3). We will call this algorithm IB-IG.
</bodyText>
<equation confidence="0.998846">
,A(X,Y) = E G(fi)5(xi,yi) (3)
</equation>
<sectionHeader confidence="0.976826" genericHeader="method">
3 IGTrees
</sectionHeader>
<bodyText confidence="0.999585285714286">
Memory-based learning is an expensive algorithm: of each test item, all feature values
must be compared to the corresponding feature values of all training items. Without
optimisation, it has an asymptotic retrieval complexity of 0(NF) (where N is the number
of items in memory, and F the number of features). The same asymptotic complexity
is of course found for memory storage in this approach. We use IGTrees (Daelemans et
al. 1996) to compress the memory. IGTree is a heuristic approximation of the IB-IG
algorithm.
</bodyText>
<subsectionHeader confidence="0.995591">
3.1 The IGTree Algorithms
</subsectionHeader>
<bodyText confidence="0.9999866">
IGTree combines two algorithms: one for compressing a case base into a trees, and one for
retrieving classification information from these trees. During the construction of IGTree
decision trees, cases are stored as paths of connected nodes. All nodes contain a test
(based on one of the features) and a class label (representing the default class at that
node). Nodes are connected via arcs denoting the outcomes for the test (feature values).
A feature relevance ordering technique (in this case information gain, see Section 2.1) is
used to determine the order in which features are used as tests in the tree. This order
is fixed in advance, so the maximal depth of the tree is always equal to the number of
features, and at the same level of the tree, all nodes have the same test (they are an
instance of oblivious decision trees; cf. Langley &amp; Sage, 1994). The reasoning behind this
reorganisation (which is in fact a compression) is that when the computation of feature
relevance points to one feature clearly being the most important in classification, search
can be restricted to matching a test case to those stored cases that have the same feature
value at that feature. Besides restricting search to those memory cases that match only
on this feature, the case memory can be optimised by further restricting search to the
</bodyText>
<page confidence="0.996358">
16
</page>
<bodyText confidence="0.75536">
Procedure BUILD-IG-TREE:
Input:
</bodyText>
<listItem confidence="0.96933925">
• A training set T of cases with their classes (start value: a full case base),
• an information-gain-ordered list of features (tests) Fz...Fn (start value: Fi...Fn).
Output: A (sub)tree.
1. If T is unambiguous (all cases in T have the same class c), create a leaf node with class label c.
2. Else if i = (n + 1), create a leaf node with as label the class occurring most frequently in T.
3. Otherwise, until i = n (the number of features)
• Select the first feature (test) Fi in F„..F7i, and construct a new node N for feature F.„ and as
default class c (the class occurring most frequently in T).
• Partition T into subsets T1...Tni according to the values 01...vrn which occur for F, in T (cases
with the same value for this feature in the same subset).
• For each je{l, m}: BUILD-IG-TREE (T3, Fi+1.-Fn),
connect the root of this subtree to N and label the arc with v.,.
</listItem>
<figureCaption confidence="0.974471">
Figure I: Algorithm for building IGTrees (`BUILD-IG-TREE&apos;).
</figureCaption>
<bodyText confidence="0.999771928571429">
second most important feature, followed by the third most important feature, etc. A
considerable compression is obtained as similar cases share partial paths.
Instead of converting the case base to a tree in which all cases are fully represented as
paths, storing all feature values, we compress the tree even more by restricting the paths
to those input feature values that disambiguate the classification from all other cases in
the training material. The idea is that it is not necessary to fully store a case as a path
when only a few feature values of the case make its classification unique. This implies that
feature values that do not contribute to the disambiguation of the case classification (i.e.,
the values of the features with lower feature relevance values than the the lowest value
of the disambiguating features) are not stored in the tree. In our tagging application,
this means that only context feature values that actually contribute to disambiguation
are used in the construction of the tree.
Leaf nodes contain the unique class label corresponding to a path in the tree. Non-
terminal nodes contain information about the most probable or default classification given
the path thus far, according to the bookkeeping information on class occurrences main-
tained by the tree construction algorithm. This extra information is essential when using
the tree for classification. Finding the classification of a new case involves traversing the
tree (i.e., matching all feature values of the test case with arcs in the order of the overall
feature information gain), and either retrieving a classification when a leaf is reached, or
using the default classification on the last matching non-terminal node if a feature-value
match fails.
A final compression is obtained by pruning the derived tree. All leaf-node daughters
of a mother node that have the same class as that node are removed from the tree, as
their class information does not contradict the default class information already present
at the mother node. Again, this compression does not affect IGTree&apos;s generalisation
performance.
The recursive algorithms for tree construction (except the final pruning) and retrieval
are given in Figures 1 and 2. For a detailed discussion, see Daelemans et al. (1996).
</bodyText>
<page confidence="0.994541">
17
</page>
<figure confidence="0.3415865">
Procedure SEARCH-IC-TREE:
Input:
</figure>
<listItem confidence="0.998197222222222">
• The root node N of a subtree (start value: top node of a complete IGTree),
• an unlabeled case I with information-gain-ordered feature values ft... fn, (start value: fi.•./.).
Output: A class label.
1. If N is a leaf node, output default class c associated with this node.
2. Otherwise, if test F, of the current node does not originate an arc labeled with ft, output default
class c associated with N.
3. Otherwise,
• new node M is the end node of the arc originating from N with as label L.
• SEARCH-IG-TREE (M, fi+i
</listItem>
<figureCaption confidence="0.988107">
Figure 2: Algorithm for searching IGTrees (&apos;SEARCH-IG-TREE&apos;).
</figureCaption>
<subsectionHeader confidence="0.983961">
3.2 IGTree Complexity
</subsectionHeader>
<bodyText confidence="0.999494909090909">
The asymptotic complexity of IGTree (i.e, in the worst case) is extremely favorable.
Complexity of searching a query pattern in the tree is proportional to F * log(V), where
F is the number of features (equal to the maximal depth of the tree), and V is the average
number of values per feature (i.e., the average branching factor in the tree). In IB1, search
complexity is 0(N * F) (with N the number of stored cases). Retrieval by search in the
tree is independent from the number of training cases, and therefore especially useful for
large case bases. Storage requirements are proportional to N (compare 0(N * F) for
IB1). Finally, the cost of building the tree on the basis of a set of cases is proportional to
N * log(V) * F in the worst case (compare 0(N) for training in IB1).
In practice, for our part-of-speech tagging experiments, IGTree retrieval is 100 to 200
times faster than normal memory-based retrieval, and uses over 95% less memory.
</bodyText>
<sectionHeader confidence="0.706181" genericHeader="method">
4 Architecture of the Tagger
</sectionHeader>
<bodyText confidence="0.999991857142857">
The architecture takes the form of a tagger generator given a corpus tagged with the
desired tag set, a POS tagger is generated which maps the words of new text to tags
in this tag set according to the same systematicity. The construction of a POS tagger
for a specific corpus is achieved in the following way. Given an annotated corpus, three
datastructures are automatically extracted: a lexicon, a case base for known words (words
occurring in the lexicon), and a case base for unknown words. Case Bases are indexed
using IGTree. During tagging, each word in the text to be tagged is looked up in the
lexicon. If it is found, its lexical representation is retrieved and its context is determined,
and the resulting pattern is looked up in the known words case base. When a word is
not found in the lexicon, its lexical representation is computed on the basis of its form,
its context is determined, and the resulting pattern is looked up in the unknown words
case base. In each case, output is a best guess of the category for the word in its current
context. In the remainder of this section, we will describe each step in more detail. We
start from a training set of tagged sentences T.
</bodyText>
<page confidence="0.999201">
18
</page>
<subsectionHeader confidence="0.965212">
4.1 Lexicon Construction
</subsectionHeader>
<bodyText confidence="0.999920055555556">
A lexicon is extracted from T by computing for each word in T the number of times it
occurs with each category. E.g. when using the first 2 million words of the Wall Street
Journal corpus&apos; as T, the word once would get the lexical definition RB: 330; IN: 77,
i.e. once was tagged 330 times as an adverb, and 77 times as a preposition/subordinating
conjunction.2
Using these lexical definitions, a new, possibly ambiguous, tag is produced for each
word type. E.g. once would get a new tag, representing the category of words which
can be both adverbs and prepositions/conjunctions (RB-IN). Frequency order is taken
into account in this process: if there would be words which, like once, can be RB or IN,
but more frequently IN than RB (e.g. the word below), then a different tag (IN-RB) is
assigned to these words. The original tag set, consisting of 44 morphosyntactic tags, was
expanded this way to 419 (possibly ambiguous) tags. In the WSJ example, the resulting
lexicon contains 57962 word types, 7464 (13%) of which are ambiguous. On the same
training set, 76% of word tokens are ambiguous.
When tagging a new sentence, words are looked up in the lexicon. Depending on
whether or not they can be found there, a case representation is constructed for them,
and they are retrieved from either the known words case base or the unknown words case
base.
</bodyText>
<subsectionHeader confidence="0.972835">
4.2 Known Words
</subsectionHeader>
<bodyText confidence="0.99996776">
A windowing approach (Sejnowski &amp; Rosenberg, 1987) was used to represent the tagging
task as a classification problem. A case consists of information about a focus word to
be tagged, its left and right context, and an associated category (tag) valid for the focus
word in that context.
There are several types of information which can be stored in the case base for each
word, ranging from the words themselves to intricate lexical representations. In the pre-
liminary experiments described in this paper, we limited this information to the possibly
ambiguous tags of words (retrieved from the lexicon) for the focus word and its context
to the right, and the disambiguated tags of words for the left context (as the result of
earlier tagging decisions). Table 1 is a sample of the case base for the first sentence of the
corpus (Pierre Vinken, 61 years old, will join the board as a nonexecutiye director nom
29) when using this case representation. The final column shows the target category; the
disambiguated tag for the focus word. We will refer to this case representation as ddf at
(d for disambiguated, f for focus, a for ambiguous, and t for target). The information
gain values are given as well.
A search among a selection of different context sizes suggested ddf at as a suitable
case representation for tagging known words. An interesting property of memory-based
learning is that case representations can be easily extended with different sources of in-
formation if available (e.g. feedback from a parser in which the tagger operates, semantic
types, the words themselves, lexical representations of words obtained from a different
source than the corpus, etc.). The information gain feature relevance ordering technique
achieves a delicate relevance weighting of different information sources when they are
fused in a single case representation. The window size used by the algorithm will also
dynamically change depending on the information present in the context for the disam-
biguation of a particular focus symbol (see Schiitze et al., 1994, and Pereira et al., 1995
</bodyText>
<footnote confidence="0.9838266">
1ACL Data Collection Initiative CD-ROM 1, September 1991.
2We disregarded a category associated with a word when less than 10% of the word tokens were tagged
with that category. This way, noise in the training material is filtered out. The value for this parameter will
have to be adapted for other training sets, and was chosen here to maximise generalization accuracy (accuracy
on tagging unseen text).
</footnote>
<page confidence="0.999557">
19
</page>
<tableCaption confidence="0.996465">
Table 1: Case representation and information gain pattern for known words.
</tableCaption>
<table confidence="0.95348675">
word d case representation d f a t
IG .06 .22 .82 .23
Pierre Vinken , = = np = np np , np np np
61 nP , np np cd nns jj-np , cd nns jj
years cd , cd nns
old cd nns jj-np
,
for similar approaches).
</table>
<subsectionHeader confidence="0.898023">
4.3 Unknown Words
</subsectionHeader>
<bodyText confidence="0.994636620689655">
If a word is not present in the lexicon, its ambiguous category cannot be retrieved. In that
case, a category can be guessed only on the basis of the form or the context of the word.
Again, we take advantage of the data fusion capabilities of a memory-based approach by
combining these two sources of information in the case representation, and having the
information gain feature relevance weighting technique figure out their relative relevance
(see Schmid, 1994; Samuelsson, 1994 for similar solutions).
In most taggers, some form of morphological analysis is performed on unknown words,
in an attempt to relate the unknown word to a known combination of known morphemes,
thereby allowing its association with one or more possible categories. After determin-
ing this ambiguous category, the word is disambiguated using context knowledge, the
same way as known words. Morphological analysis presupposes the availability of highly
language-specific resources such as a morpheme lexicon, spelling rules, morphological
rules, and heuristics to prioritise possible analyses of a word according to their plausi-
bility. This is a serious knowledge engineering bottleneck when the goal is to develop a
language and annotation-independent tagger generator.
In our memory-based approach, we provide morphological information (especially
about suffixes) indirectly to the tagger by encoding the three last letters of the word
as separate features in the case representation. The first letter is encoded as well because
it contains information about prefix and capitalization of the word. Context information
is added to the case representation in a similar way as with known words. It turned out
that in combination with the &apos;morphological&apos; features, a context of one disambiguated tag
of the word to the left of the unknown word and one ambiguous category of the word to
the right, gives good results. We will call this case representation pdassst:3 three suffix
letters (s), one prefix letter (p), one left disambiguated context words (d), and one am-
biguous right context word (a). As the chance of an unknown word being a function word
is small, and cases representing function words may interfere with correct classification
of open-class words, only open-class words are used during construction of the unknown
words case base.
Table 2 shows part of the case base for unknown words.
</bodyText>
<footnote confidence="0.983342">
3These parameters (optimal context size and number of suffix features) were again optimised for general-
ization accuracy.
</footnote>
<page confidence="0.99905">
20
</page>
<tableCaption confidence="0.974654">
Table 2: Case representation and information gain pattern for unknown words.
</tableCaption>
<table confidence="0.9936445">
word p d case representation a s s s t
IG .21 .21 .14 .15 .20 .32
Pierre Vinken 61 P V 6 y o = np r k = r e 6 r 1 e n 1 s d np np cd nns
years np , a o jj
old , nns jj-np
cd nns ,
</table>
<subsectionHeader confidence="0.946714">
4.4 Control
</subsectionHeader>
<bodyText confidence="0.999501222222222">
Figure 3 shows the architecture of the tagger-generator: a tagger is produced by extracting
a lexicon and two case-bases from the tagged example corpus. During tagging, the control
is the following: words are looked up in the lexicon and separated into known and unknown
words. They are retrieved from the known words case base and the unknown words case
base, respectively. In both cases, context is used, in the case of unknown words, the first
and three last letters of the word are used instead of the ambiguous tag for the focus
word. As far as disambiguated tags for left context words are used, these are of course
not obtained by retrieval from the lexicon (which provides ambiguous categories), but by
using the previous decisions of the tagger.
</bodyText>
<figure confidence="0.9914028">
TAGGER GENERATION TAGGING
LEXICON word -&gt; a
KNOWN WORDS ■ CASE BASE
ddfa -&gt; t
UNKNOWN WORDS i CASE BASE
pdasss -&gt; t
TAGGER
Tagged Corpus
New Text
- Tagged Text
</figure>
<figureCaption confidence="0.999874">
Figure 3: Architecture of the tagger-generator: flow of control.
</figureCaption>
<subsectionHeader confidence="0.886752">
4.5 IGTrees for Tagging
</subsectionHeader>
<bodyText confidence="0.999914">
As explained earlier, both case bases are implemented as IGTrees. For the known words
case base, paths in the tree represent variable size context widths. The first feature
(the expansion of the root node of the tree) is the focus word, then context features are
added as further expansions of the tree until the context disambiguates the focus word
completely. Further expansion is halted at that point. In some cases, short context sizes
(corresponding to bigrams, e g) are sufficient to disambiguate a focus word, in other cases,
more context is needed. IGTrees provide an elegant way of automatic determination of
</bodyText>
<page confidence="0.999078">
21
</page>
<bodyText confidence="0.9982198">
optimal context size. In the unknown words case base, the trie representation provides
an automatic integration of information about the form and the context of a focus word
not encountered before. In general, the top levels of the tree represent the morphological
information (the three suffix letter features and the prefix letter), while the deeper levels
contribute contextual disambiguation.
</bodyText>
<sectionHeader confidence="0.999519" genericHeader="method">
5 Experiments
</sectionHeader>
<bodyText confidence="0.9994402">
In this section, we report first results on our memory-based tagging approach. In a first
set of experiments, we compared our IGTree implementation of memory-based learning
to more traditional implementations of the approach. In further experiments we studied
the performance of our system on predicting the category of both known and unknown
words.
</bodyText>
<subsectionHeader confidence="0.77236">
Experimental Set-up
</subsectionHeader>
<bodyText confidence="0.999896375">
The experimental methodology was taken from Machine Learning practice (e.g. Weiss
&amp; Kulikowski, 1991): independent training and test sets were selected from the origi-
nal corpus, the system was trained on the training set, and the generalization accuracy
(percentage of correct category assignments) was computed on the independent test set.
Storage and time requirements were computed as well. Where possible, we used a 10-fold
cross-validation approach. In this experimental method, a data set is partitioned ten
times into 90% training material, and 10% testing material. Average accuracy provides a
reliable estimate of the generalization accuracy.
</bodyText>
<subsectionHeader confidence="0.980227">
5.1 Experiment 1: Comparison of Algorithms
</subsectionHeader>
<bodyText confidence="0.998765833333333">
Our goal is to adhere to the concept of memory-based learning with full memory while
at the same time keeping memory and processing speed within attractive bounds. To
this end, we applied the IGTree formalism to the task. In order to prove that IGTree is a
suitable candidate for practical memory-based tagging, we compared three memory-based
learning algorithms: (i) IB1, a slight extension (to cope with symbolic values and ambigu-
ous training items) of the well-known k-nn algorithm in statistical pattern recognition (see
Aha et al., 1991), (ii) IB1-IG, an extension of IB1 which uses feature relevance weighting
(described in Section 2), and (iii) IGTree, a memoryand processing time saving heuris-
tic implementation of IB1-IG (see Section 3). Table 3 lists the results in generalization
accuracy, storage requirements and speed for the three algorithms using a ddf at pattern,
a 100,000 word training set, and a 10,000 word test set. In this experiment, accuracy was
tested on known words only.
</bodyText>
<tableCaption confidence="0.998566">
Table 3: Comparison of three memory-based learning techniques.
</tableCaption>
<table confidence="0.99758875">
Algorithm Accuracy Time Memory (Kb)
IB1 92.5 0:43:34 977
IB1-IG 96.0 0:49:45 977
IGTree 96.0 0:00:29 35
</table>
<bodyText confidence="0.9870505">
The IGTree version turns out to be better or equally good in terms of generalization
accuracy, but also is more than 100 times faster for tagging of new words4, and compresses
</bodyText>
<footnote confidence="0.978863">
4In training, i.e. building the case base, TM. and IB1-IG (4 seconds) are faster than IGTree (26 seconds)
because the latter has to build a tree instead of just storing the patterns.
</footnote>
<page confidence="0.998981">
22
</page>
<bodyText confidence="0.99994175">
the original case base to 4% of the size of the original case base. This experiment shows
that for this problem, we can use IGTree as a time and memory saving approximation
of memory-based learning (IB-IG version), without loss in generalization accuracy. The
time and speed advantage of IGTree grows with larger training sets.
</bodyText>
<subsectionHeader confidence="0.995545">
5.2 Experiment 2: Learning Curve
</subsectionHeader>
<bodyText confidence="0.995272142857143">
A ten-fold cross-validation experiment on the first two million words of the WSJ corpus
shows an average generalization performance of IGTree (on known words only) of 96.3%.
We did 10-fold cross-validation experiments for several sizes of datasets (in steps of 100,000
memory items), revealing the learning curve in Figure 4. Training set size is on the X-axis,
generalization performance as measured in a 10-fold cross-validation experiment is on the
Y-axis. the &apos;error&apos; range indicate averages plus and minus one standard deviation on each
10-fold cross-validation experiment.&apos;
</bodyText>
<figure confidence="0.898410285714286">
Part of Speech Tagging Learning Curve
96.4
96.2
96 95.8 95.6 95.4 95.2
95 94.8 94.6
500 1000 1500 2000
Training size (x1000)
</figure>
<figureCaption confidence="0.999906">
Figure 4: Learning curve for tagging.
</figureCaption>
<bodyText confidence="0.999813142857143">
Already at small data set sizes, performance is relatively high. With increasingly
larger data sets, the performance becomes more stable (witness the error ranges). It
should be noted that in this experiment, we assumed correctly disambiguated tags in the
left context. In practice, when using our tagger, this is of course not the case because the
disambiguated tags in the left context of the current word to be tagged are the result of
a previous decision of the tagger, which may be a mistake. To test the influence of this
effect we performed a third experiment.
</bodyText>
<subsectionHeader confidence="0.969687">
5.3 Experiment 3: Overall Accuracy
</subsectionHeader>
<bodyText confidence="0.996273714285714">
We performed the complete tagger generation process on a 2 million words training set
(lexicon construction and known and unknown words case-base construction), and tested
on 200,000 test words. Performance on known words, unknown words, and total are given
in Table 4. In this experiment, numbers were not stored in the known words case base;
they are looked up in the unknown words case base.
&apos;We are not convinced that variation in the results of the experiments in a 10-fold-cv set-up is statistically
meaningful (the 10 experiments are not independent), but follow common practice here.
</bodyText>
<page confidence="0.999568">
23
</page>
<tableCaption confidence="0.996641">
Table 4: Accuracy of IGTree tagging on known and unknown words
</tableCaption>
<table confidence="0.99936025">
Accuracy Percentage
Known 96.7 94.5
Unknown 90.6 5.5
Total 96.4 100.0
</table>
<sectionHeader confidence="0.993192" genericHeader="method">
6 Related Research
</sectionHeader>
<bodyText confidence="0.999975380952381">
A case-based approach, similar to our memory-based approach, was also proposed by
Cardie (1993a, 1994) for sentence analysis in limited domains (not only POS tagging but
also semantic tagging and structural disambiguation). We will discuss only the reported
POS tagging results here. Using a fairly complex case representation based on output from
the CIRCUS conceptual sentence analyzer (22 local context features describing syntactic
and semantic information about a five-word window centered on the word to be tagged,
including the words themselves, and 11 global context features providing information
about the major constituents parsed already), and with a tag set of 18 tags (7 open-class,
11 closed class), she reports a 95% tagging accuracy. A decision-tree learning approach
to feature selection is used in this experiment (Cardie, 1993b, 1994) to discard irrelevant
features. Results are based on experiments with 120 randomly chosen sentences from
the TIPSTER JV corpus (representing 2056 cases). Cardie (p.c.) reports 89.1% correct
tagging for unknown words. Percentage unknown words was 20.6% of the test words,
and overall tagging accuracy (known and unknown) 95%. Notice that her algorithm
gives no initial preference to training cases that match the test word during its initial
case retrieval. On the other hand, after retrieving the top k cases, the algorithm does
prefer those cases that match the test word when making its final predictions. So, it&apos;s
understandable that the algorithm is doing better on words that it&apos;s seen during training
as opposed to unknown words.
In our memory-based approach, feature weighting (rather than feature selection) for
determining the relevance of features is integrated more smoothly with the similarity
metric, and our results are based on experiments with a larger corpus (3 million cases).
Our case representation is (at this point) simpler: only the (ambiguous) tags, not the
words themselves or any other information are used. The most important improvement is
the use of IGTree to index and search the case base, solving the computational complexity
problems a case-based approach would run into when using large case bases.
An approach based on k-nn methods (such as memory-based and case-based methods)
is a statistical approach, but it uses a different kind of statistics than Markov model-based
approaches. K-nn is a non-parametric technique; it assumes no fixed type of distribution
of the data. The most important advantages compared to current stochastic approaches
are that (i) few training items (a small tagged corpus) are needed for relatively good
performance, (ii) the approach is incremental: adding new cases does not require any
recomputation of probabilities, and (iii) it provides explanation capabilities, and (iv) it
requires no additional smoothing techniques to avoid zero-probabilities; the IGTree takes
care of that.
Compared to hand-crafted rule-based approaches, our approach provides a solution
to the knowledge-acquisition and reusability bottlenecks, and to robustness and cover-
age problems (similar advantages motivated Markov model-based statistical approaches).
Compared to learning rule-based approaches such as the one by Brill (1992), a k-nn ap-
proach provides a uniform approach for all disambiguation tasks, more flexibility in the
engineering of case representations, and a more elegant approach to handling of unknown
words (see e.g. Cardie 1994).
</bodyText>
<page confidence="0.999433">
24
</page>
<sectionHeader confidence="0.999403" genericHeader="conclusions">
7 Conclusion
</sectionHeader>
<bodyText confidence="0.999987714285714">
We have shown that a memory-based approach to large-scale tagging is feasible both
in terms of accuracy (comparable to other statistical approaches), and also in terms of
computational efficiency (time and space requirements) when using IGTree to compress
and index the case base. The approach combines some of the best features of learned
rule-based and statistical systems (small training corpora needed, incremental learning,
understandable and explainable behavior of the system). More specifically, memory-based
tagging with IGTrees has the following advantages.
</bodyText>
<listItem confidence="0.958196407407408">
• Accurate generalization from small tagged corpora. Already at small corpus size
(300-400 K tagged words), performance is good. These corpus sizes can be easily
handled by our system.
• Incremental learning. New &apos;cases&apos; (e.g. interactively corrected output of the tagger)
can be incrementally added to the case bases, continually improving the performance
of the overall system.
• Explanation capabilities. To explain the classification behavior of the system, a path
in the IGTree (with associated defaults) can be provided as an explanation, as well
as nearest neighbors from which the decision was extrapolated.
• Flexible integration of information sources. The feature weighting method takes
care of the optimal fusing of different sources of information (e.g. word form and
context), automatically.
• Automatic selection of optimal context. The IGTree mechanism (when applied to
the known words case base) automatically decides on the optimal context size for
disambiguation of focus words.
• Non-parametric estimation. The IGTree formalism provides automatic, nonparametric
estimation of classifications for low-frequency contexts (it is similar in this respect
to backed-off training), but avoids non-optimal estimation due to false intuitions or
non-convergence of the gradient-descent procedure used in some versions of backed-
off training.
• Reasonably good results on unknown words without morphological analysis. On
the WSJ corpus, unknown words can be predicted (using context and word form
information) for more than 90%.
• Fast learning and tagging. Due to the favorable complexity properties of IGTrees
(lookup time in IGTrees is independent on number of cases), both tagger generation
and tagging are extremely fast. Tagging speed in our current implementation is
about 1000 words per second.
</listItem>
<bodyText confidence="0.999967166666667">
We have barely begun to optimise the approach: a more intelligent similarity metric
would also take into account the differences in similarity between different values of the
same feature. E.g. the similarity between the tags rb-in-nn and rb-in should be bigger than
the similarity between rb-in and vb-nn. Apart from linguistic engineering refinements of
the similarity metric, we are currently experimenting with statistical measures to compute
such more fine-grained similarities (e.g. Stanfill &amp; Waltz, 1986, Cost &amp; Salzberg, 1994).
</bodyText>
<sectionHeader confidence="0.980027" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.99945625">
Research of the first author was done while he was a visiting scholar at NIAS (Netherlands
Institute for Advanced Studies) in Wassenaar. Thanks to Antal van den Bosch, Ton
Weijters, and Gert Durieux for discussions about tagging, IGTree, and machine learning
of natural language.
</bodyText>
<page confidence="0.999222">
25
</page>
<sectionHeader confidence="0.998109" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9997342">
Aha, D. W., Kibler, D., &amp; Albert, M. (1991). &apos;Instance-based learning algorithms&apos;.
Machine Learning, 7, 37-66.
Brill, E. (1992) &apos;A simple rule-based part-of-speech tagger&apos;. Proceedings Third ACL
Applied, Trento, Italy, 152-155.
Cardie, C. (1993a). &apos;A case-based approach to knowledge acquisition for domain-specific
sentence analysis&apos;. In AAAI-93, 798-803.
Cardie, C. (1993b). &apos;Using Decision Trees to Improve Case-Based Learning&apos;. In Pro-
ceedings of the Tenth International Conference on Machine Learning, 25-32.
Cardie, C. (1994). &apos;Domain-Specific Knowledge Acquisition for Conceptual Sentence
Analysis&apos;. Ph.D. Thesis, University of Massachusetts, Amherst, MA.
Chandler, S. (1992). &apos;Are rules and modules really necessary for explaining language?&apos;
Journal of Psycholinguistic research, 22(6): 593-606.
Church, K. (1988). &apos;A stochastic parts program and noun phrase parser for unrestricted
text&apos;. Proceedings Second ACL Applied NLP, Austin, Texas, 136-143.
Cost, S. and Salzberg, S. (1993). &apos;A weighted nearest neighbour algorithm for learning
with symbolic features.&apos; Machine Learning, 10, 57-78.
Cutting, D., Kupiec, J., Pederson, J., Sibun, P. (1992). A practical part of speech tagger.
Proceedings Third ACL Applied NLP, Trento, Italy, 133-140.
Daelemans, W. (1995). &apos;Memory-based lexical acquisition and processing.&apos; In Steffens,
P., editor, Machine Translation and the Lexicon, Lecture Notes in Artificial Intelli-
gence 898. Berlin: Springer, 85-98.
Daelemans, W., Van den Bosch, A. (1992). &apos;Generalisation performance of backprop-
agation learning on a syllabification task.&apos; In M. Drossaers &amp; A. Nijholt (Eds.),
TWLT3: Connectionism and Natural Language Processing. Enschede: Twente Uni-
versity, 27-38.
Daelemans, W., Van den Bosch, A., Weijters, T. (1996). &apos;IGTree: Using Trees for
Compression and Classification in Lazy Learning Algorithms.&apos; In Aha, D. (ed.). Al
Review Special Issue on Lazy Learning, forthcoming.
DeRose, S. (1988). &apos;Grammatical category disambiguation by statistical optimization.
Computational Linguistics 14, 31-39.
Derwing, B. L. and Skousen, R. (1989). &apos;Real Time Morphology: Symbolic Rules or
Analogical Networks&apos;. Berkeley Linguistic Society 15: 48-62.
Federici S. and V. Pirelli. (1996). &apos;Analogy, Computation and Linguistic Theory.&apos; In
Jones, D. (ed.) New Methods in Language Processing. London: UCL Press, forth-
coming.
Garside, R., Leech, G. and Sampson, G. (1987). The computational analysis of English:
A corpus-based approach, London: Longman, 1987.
Greene, B.B. and Rubin, G.M. (1971). Automatic Grammatical Tagging of English.
Providence RI: Department of Linguistics, Brown University.
Hindle, Donald. (1989). &apos;Acquiring disambiguation rules from text.&apos; In Proceedings,
27th Annual Meeting of the Association for Computational Linguistics, Vancouver,
BC.
Hunt, E., J. Mann, P. Stone. (1966). Experiments in Induction. New York: Academic
Press.
Jones, D. Analogical Natural Language Processing. London: UCL Press, 1996.
</reference>
<page confidence="0.96027">
26
</page>
<reference confidence="0.9995655">
Klein S. and Simmons, R. (1963). &apos;A grammatical approach to grammatical coding of
English words.&apos; JACM 10, 334-347.
Kolodner, J. (1993). Case-Based Reasoning. San Mateo: Morgan Kaufmann.
Langley, P. and Sage, S. (1994). &apos;Oblivious decision trees and abstract cases.&apos; In
D. W. Aha (Ed.), Case-Based Reasoning: Papers from the 1994 Workshop (Techni-
cal Report WS-94-01). Menlo Park, CA: AAAI Press.
Merialdo, B. ( 1994). &apos;Tagging English Text with a Probabilistic Model.&apos; Computational
Linguistics 20 (2), 155-172.
Pereira, F., Y. Singer, N. Tishby. (1995). &apos;Beyond Word N-grams.&apos; Proceedings Third
Workshop on Very Large Corpora, MIT, Cambridge Mass., 95-106.
Quinlan, J. (1993). C4.5: Programs for Machine Learning. San Mateo, CA: Morgan
Kaufmann.
Salzberg, S. (1990) &apos;A nearest hyperrectangle learning method&apos;. Machine Learning 6,
251-276.
Samuelsson, C. (1994) &apos;Morphological Tagging Based Entirely on Bayesian Inference.&apos; In
Proceedings of the 9th Nordic Conference on Computational Linguistics, Stockholm
University, Sweden, 1994.
Scha, R. (1992) &apos;Virtuele Grammatica&apos;s en Creatieve Algoritmen.&apos; Gramma/TTT 1 (1),
57-77.
Schmid, H. (1994) &apos;Part-of-speech tagging with neural networks.&apos; In Proceedings of
COLING, Kyoto, Japan.
Schiitze, H., and Y. Singer. (1994) &apos;Part-of-speech Tagging Using a Variable Context
Markov Model&apos; Proceedings of ACL 1994, Las Cruces, New Mexico.
Skousen, R. (1989). Analogical Modeling of Language. Dordrecht: Kluwer.
Sejnowski, T. J., Rosenberg, C. S. (1987). Parallel networks that learn to pronounce
English text. Complex Systems, 1, 145-168.
Stanfill, C. and Waltz, D. (1986). &apos;Toward memory-based reasoning.&apos; Communications
of the ACM, 29, 1212-1228.
Weiss, S. and Kulikowski, C. (1991). Computer systems that learn. San-Mateo: Morgan
Kaufmann.
</reference>
<page confidence="0.999341">
27
</page>
</variant>
</algorithm>
</algorithms>